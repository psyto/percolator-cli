/**
 * Oracle Authority Pen-Test
 *
 * Uses admin oracle authority to simulate adversarial price scenarios and
 * stress test the percolator program's defenses against:
 *
 * 1. Flash crash attacks - sudden price drops to mass-liquidate
 * 2. Insurance fund drain - manipulate prices to extract insurance
 * 3. ADL cascade - trigger auto-deleveraging edge cases
 * 4. Funding rate manipulation - extreme imbalance exploitation
 * 5. Price edge cases - zero, max value, negative scenarios
 * 6. Timestamp attacks - stale/future timestamps
 */

import { Connection, Keypair, PublicKey, Transaction, ComputeBudgetProgram, sendAndConfirmTransaction, SYSVAR_CLOCK_PUBKEY, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";
import { getOrCreateAssociatedTokenAccount, TOKEN_PROGRAM_ID, NATIVE_MINT, createSyncNativeInstruction } from "@solana/spl-token";
import { fetchSlab, parseEngine, parseParams, parseAccount, parseUsedIndices, parseConfig, parseHeader, AccountKind } from "../src/solana/slab.js";
import { encodeKeeperCrank, encodeSetOracleAuthority, encodePushOraclePrice, encodeInitUser, encodeDepositCollateral, encodeTradeCpi, encodeLiquidateAtOracle } from "../src/abi/instructions.js";
import { buildAccountMetas, ACCOUNTS_KEEPER_CRANK, ACCOUNTS_SET_ORACLE_AUTHORITY, ACCOUNTS_PUSH_ORACLE_PRICE, ACCOUNTS_INIT_USER, ACCOUNTS_DEPOSIT_COLLATERAL, ACCOUNTS_TRADE_CPI, ACCOUNTS_LIQUIDATE_AT_ORACLE } from "../src/abi/accounts.js";
import { buildIx } from "../src/runtime/tx.js";
import fs from "fs";

const marketInfo = JSON.parse(fs.readFileSync("devnet-market.json", "utf-8"));
const PROGRAM_ID = new PublicKey(marketInfo.programId);
const MATCHER_PROGRAM = new PublicKey(marketInfo.matcherProgramId);
const SLAB = new PublicKey(marketInfo.slab);
const ORACLE = new PublicKey(marketInfo.oracle);
const VAULT = new PublicKey(marketInfo.vault);
const LP_IDX = marketInfo.lp.index;
const MATCHER_CTX = new PublicKey(marketInfo.lp.matcherContext);

const conn = new Connection(process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com", "confirmed");
const payer = Keypair.fromSecretKey(
  new Uint8Array(JSON.parse(fs.readFileSync(process.env.HOME + "/.config/solana/id.json", "utf-8")))
);

function deriveLpPda(slabPubkey: PublicKey, lpIndex: number): PublicKey {
  const [pda] = PublicKey.findProgramAddressSync(
    [Buffer.from("lp"), slabPubkey.toBuffer(), Buffer.from([lpIndex & 0xff, (lpIndex >> 8) & 0xff])],
    PROGRAM_ID
  );
  return pda;
}

function deriveVaultPda(slabPubkey: PublicKey): PublicKey {
  const [pda] = PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), slabPubkey.toBuffer()],
    PROGRAM_ID
  );
  return pda;
}

// ============================================================================
// ORACLE AUTHORITY FUNCTIONS
// ============================================================================

async function setOracleAuthority(authority: PublicKey): Promise<boolean> {
  const data = encodeSetOracleAuthority({ newAuthority: authority });
  const keys = buildAccountMetas(ACCOUNTS_SET_ORACLE_AUTHORITY, [payer.publicKey, SLAB]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 50_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    console.log(`SetOracleAuthority failed: ${e.message?.slice(0, 80)}`);
    return false;
  }
}

async function pushPrice(priceUsd: number, timestamp?: number): Promise<boolean> {
  const priceE6 = BigInt(Math.round(priceUsd * 1_000_000));
  const ts = timestamp ?? Math.floor(Date.now() / 1000);

  const data = encodePushOraclePrice({ priceE6, timestamp: BigInt(ts) });
  const keys = buildAccountMetas(ACCOUNTS_PUSH_ORACLE_PRICE, [payer.publicKey, SLAB]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 50_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    console.log(`PushPrice $${priceUsd} failed: ${e.message?.slice(0, 100)}`);
    return false;
  }
}

async function crank(): Promise<boolean> {
  const data = encodeKeeperCrank({ callerIdx: 65535, allowPanic: false });
  const keys = buildAccountMetas(ACCOUNTS_KEEPER_CRANK, [payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 500_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    console.log(`Crank failed: ${e.message?.slice(0, 100)}`);
    return false;
  }
}

// ============================================================================
// TRADER SETUP FUNCTIONS
// ============================================================================

async function initUser(feePayment: bigint = 1_000_000n): Promise<number | null> {
  const userAta = await getOrCreateAssociatedTokenAccount(conn, payer, NATIVE_MINT, payer.publicKey);

  const data = encodeInitUser({ feePayment });
  const keys = buildAccountMetas(ACCOUNTS_INIT_USER, [
    payer.publicKey, SLAB, userAta.address, VAULT, TOKEN_PROGRAM_ID
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    // Find the new user index
    const slabData = await fetchSlab(conn, SLAB);
    const indices = parseUsedIndices(slabData);
    const userIndices = indices.filter(idx => {
      const acc = parseAccount(slabData, idx);
      return acc && acc.kind === AccountKind.User;
    });
    return userIndices[userIndices.length - 1];
  } catch (e: any) {
    console.log(`InitUser failed: ${e.message?.slice(0, 100)}`);
    return null;
  }
}

async function deposit(userIdx: number, amount: bigint): Promise<boolean> {
  // Wrap SOL first
  const userAta = await getOrCreateAssociatedTokenAccount(conn, payer, NATIVE_MINT, payer.publicKey);
  const wrapTx = new Transaction().add(
    SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: userAta.address, lamports: Number(amount) }),
    createSyncNativeInstruction(userAta.address)
  );
  await sendAndConfirmTransaction(conn, wrapTx, [payer], { commitment: "confirmed" });

  const data = encodeDepositCollateral({ userIdx, amount });
  const keys = buildAccountMetas(ACCOUNTS_DEPOSIT_COLLATERAL, [
    payer.publicKey, SLAB, userAta.address, VAULT, TOKEN_PROGRAM_ID, SYSVAR_CLOCK_PUBKEY
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    console.log(`Deposit failed: ${e.message?.slice(0, 100)}`);
    return false;
  }
}

async function trade(userIdx: number, size: bigint): Promise<boolean> {
  const lpPda = deriveLpPda(SLAB, LP_IDX);
  const data = encodeTradeCpi({ lpIdx: LP_IDX, userIdx, size: size.toString() });
  const keys = buildAccountMetas(ACCOUNTS_TRADE_CPI, [
    payer.publicKey, payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE,
    MATCHER_PROGRAM, MATCHER_CTX, lpPda
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 400_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    console.log(`Trade failed: ${e.message?.slice(0, 100)}`);
    return false;
  }
}

async function liquidate(targetIdx: number): Promise<boolean> {
  const data = encodeLiquidateAtOracle({ targetIdx });
  const keys = buildAccountMetas(ACCOUNTS_LIQUIDATE_AT_ORACLE, [
    payer.publicKey, SLAB, SYSVAR_CLOCK_PUBKEY, ORACLE
  ]);
  const tx = new Transaction().add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 400_000 }),
    buildIx({ programId: PROGRAM_ID, keys, data })
  );
  try {
    await sendAndConfirmTransaction(conn, tx, [payer], { commitment: "confirmed" });
    return true;
  } catch (e: any) {
    console.log(`Liquidate ${targetIdx} failed: ${e.message?.slice(0, 100)}`);
    return false;
  }
}

// ============================================================================
// STATE HELPERS
// ============================================================================

async function getState() {
  const data = await fetchSlab(conn, SLAB);
  return {
    header: parseHeader(data),
    engine: parseEngine(data),
    params: parseParams(data),
    config: parseConfig(data),
    data,
  };
}

function sleep(ms: number): Promise<void> {
  return new Promise(r => setTimeout(r, ms));
}

// ============================================================================
// PEN-TEST SCENARIOS
// ============================================================================

interface PenTestResult {
  name: string;
  passed: boolean;
  details: string;
  vulnerability?: string;
}

async function testFlashCrash(): Promise<PenTestResult> {
  console.log("\n=== PEN-TEST: Flash Crash Attack ===");
  console.log("Goal: Sudden price drop to mass-liquidate profitable positions\n");

  const { engine: before } = await getState();
  const insuranceBefore = Number(before.insuranceFund.balance) / 1e9;
  const liqsBefore = Number(before.lifetimeLiquidations);

  // Setup: Create trader with leveraged LONG position
  console.log("1. Setting up leveraged trader...");
  await pushPrice(140);
  await crank();

  const userIdx = await initUser();
  if (!userIdx) return { name: "Flash Crash", passed: false, details: "Failed to create user" };

  await deposit(userIdx, BigInt(2 * LAMPORTS_PER_SOL)); // 2 SOL collateral
  await crank();
  await sleep(1000);

  // Open LONG position (10x leverage at ~$140)
  // Position size = 2 SOL * 10 = 20 SOL notional value
  const posSize = 1_000_000_000_000n; // Large position
  const tradeOk = await trade(userIdx, posSize);
  if (!tradeOk) {
    console.log("  Trade failed - may need more LP liquidity");
  }
  await crank();

  // Attack: Flash crash to 50% of price
  console.log("\n2. Executing flash crash: $140 -> $70...");
  await pushPrice(70);
  await crank();

  // Try to liquidate
  console.log("3. Attempting liquidation...");
  const liqOk = await liquidate(userIdx);

  // Check results
  const { engine: after } = await getState();
  const insuranceAfter = Number(after.insuranceFund.balance) / 1e9;
  const liqsAfter = Number(after.lifetimeLiquidations);

  // Restore price
  await pushPrice(140);
  await crank();

  const liquidated = liqsAfter > liqsBefore;
  const insuranceDrained = insuranceAfter < insuranceBefore - 0.1;

  console.log(`\nResults:`);
  console.log(`  Liquidations: ${liqsBefore} -> ${liqsAfter}`);
  console.log(`  Insurance: ${insuranceBefore.toFixed(4)} -> ${insuranceAfter.toFixed(4)} SOL`);

  return {
    name: "Flash Crash Attack",
    passed: !insuranceDrained, // Passed if insurance not significantly drained
    details: `Liquidated: ${liquidated}, Insurance delta: ${(insuranceAfter - insuranceBefore).toFixed(4)}`,
    vulnerability: insuranceDrained ? "Insurance fund can be drained via flash crash" : undefined
  };
}

async function testPriceEdgeCases(): Promise<PenTestResult> {
  console.log("\n=== PEN-TEST: Price Edge Cases ===");
  console.log("Goal: Test program behavior at extreme prices\n");

  const testCases = [
    { name: "Zero price", price: 0 },
    { name: "Near-zero", price: 0.000001 },
    { name: "Very high", price: 1_000_000 },
    { name: "Max safe", price: Number.MAX_SAFE_INTEGER / 1e6 },
  ];

  const results: string[] = [];

  for (const tc of testCases) {
    console.log(`  Testing ${tc.name} ($${tc.price})...`);
    const ok = await pushPrice(tc.price);
    if (ok) {
      const crankOk = await crank();
      results.push(`${tc.name}: push=${ok}, crank=${crankOk}`);
    } else {
      results.push(`${tc.name}: REJECTED (good)`);
    }
    await sleep(500);
  }

  // Restore normal price
  await pushPrice(140);
  await crank();

  const zeroAccepted = results.some(r => r.includes("Zero") && r.includes("push=true"));

  return {
    name: "Price Edge Cases",
    passed: !zeroAccepted,
    details: results.join("; "),
    vulnerability: zeroAccepted ? "Zero price accepted - could break calculations" : undefined
  };
}

async function testTimestampAttack(): Promise<PenTestResult> {
  console.log("\n=== PEN-TEST: Timestamp Manipulation ===");
  console.log("Goal: Test stale/future timestamp handling\n");

  const now = Math.floor(Date.now() / 1000);
  const testCases = [
    { name: "Stale (1 hour ago)", ts: now - 3600 },
    { name: "Very stale (1 day)", ts: now - 86400 },
    { name: "Future (1 hour)", ts: now + 3600 },
    { name: "Far future (1 year)", ts: now + 31536000 },
    { name: "Epoch 0", ts: 0 },
    { name: "Negative", ts: -1 },
  ];

  const results: string[] = [];

  for (const tc of testCases) {
    console.log(`  Testing ${tc.name} (ts=${tc.ts})...`);
    const ok = await pushPrice(140, tc.ts);
    results.push(`${tc.name}: ${ok ? "ACCEPTED" : "rejected"}`);
    await sleep(500);
  }

  // Restore with current timestamp
  await pushPrice(140);
  await crank();

  const staleAccepted = results.some(r => r.includes("Stale") && r.includes("ACCEPTED"));
  const futureAccepted = results.some(r => r.includes("Future") && r.includes("ACCEPTED"));

  return {
    name: "Timestamp Attack",
    passed: true, // Just informational
    details: results.join("; "),
    vulnerability: staleAccepted ? "Stale timestamps accepted" :
                   futureAccepted ? "Future timestamps accepted" : undefined
  };
}

async function testFundingManipulation(): Promise<PenTestResult> {
  console.log("\n=== PEN-TEST: Funding Rate Manipulation ===");
  console.log("Goal: Extreme price swings to extract funding\n");

  const { engine: before } = await getState();
  const fundingBefore = before.fundingIndexQpbE6;

  // Rapid price oscillation
  const prices = [140, 200, 100, 250, 80, 300, 60];

  for (const p of prices) {
    await pushPrice(p);
    await crank();
    await sleep(300);
  }

  const { engine: after } = await getState();
  const fundingAfter = after.fundingIndexQpbE6;
  const fundingDelta = Number(fundingAfter - fundingBefore);

  // Restore
  await pushPrice(140);
  await crank();

  return {
    name: "Funding Manipulation",
    passed: true,
    details: `Funding index delta: ${fundingDelta}`,
    vulnerability: Math.abs(fundingDelta) > 10000 ? "Large funding swings possible" : undefined
  };
}

async function testInsuranceDrain(): Promise<PenTestResult> {
  console.log("\n=== PEN-TEST: Insurance Fund Drain ===");
  console.log("Goal: Attempt to drain insurance via bad debt\n");

  const { engine: before, params } = await getState();
  const insuranceBefore = Number(before.insuranceFund.balance) / 1e9;

  // Create highly leveraged position, then crash
  const userIdx = await initUser();
  if (!userIdx) return { name: "Insurance Drain", passed: false, details: "Failed to create user" };

  await deposit(userIdx, BigInt(0.5 * LAMPORTS_PER_SOL)); // Minimal collateral
  await crank();
  await sleep(1000);

  // Try max leverage trade
  await pushPrice(140);
  await crank();

  const tradeOk = await trade(userIdx, 500_000_000_000n); // Try large position

  if (tradeOk) {
    // Crash to create bad debt
    await pushPrice(10); // -93% crash
    await crank();

    // Try liquidation
    await liquidate(userIdx);
  }

  const { engine: after } = await getState();
  const insuranceAfter = Number(after.insuranceFund.balance) / 1e9;

  // Restore
  await pushPrice(140);
  await crank();

  const drained = insuranceAfter < insuranceBefore * 0.5; // More than 50% loss

  return {
    name: "Insurance Drain",
    passed: !drained,
    details: `Insurance: ${insuranceBefore.toFixed(4)} -> ${insuranceAfter.toFixed(4)} SOL`,
    vulnerability: drained ? "Insurance fund can be significantly drained" : undefined
  };
}

async function testADLCascade(): Promise<PenTestResult> {
  console.log("\n=== PEN-TEST: ADL Cascade ===");
  console.log("Goal: Trigger auto-deleveraging edge cases\n");

  // Would need multiple users with positions for full ADL testing
  // For now, just verify ADL doesn't crash with extreme imbalance

  const { engine: before } = await getState();

  // Create extreme LP imbalance by crashing price with positions
  await pushPrice(200); // Pump
  await crank();
  await pushPrice(50);  // Crash
  await crank();
  await pushPrice(300); // Pump
  await crank();
  await pushPrice(30);  // Severe crash
  await crank();

  const { engine: after } = await getState();
  const riskMode = after.riskReductionOnly;

  // Restore
  await pushPrice(140);
  await crank();

  return {
    name: "ADL Cascade",
    passed: true,
    details: `Risk reduction mode: ${riskMode}, Loss accum: ${after.lossAccum}`,
    vulnerability: riskMode ? "Risk reduction triggered by price manipulation" : undefined
  };
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
  console.log("=".repeat(70));
  console.log("PERCOLATOR ORACLE AUTHORITY PEN-TEST");
  console.log("=".repeat(70));
  console.log("\nThis script uses oracle authority to simulate adversarial scenarios.\n");

  // Ensure oracle authority is set
  const { config } = await getState();
  if (config.oracleAuthority.equals(PublicKey.default)) {
    console.log("Setting oracle authority...");
    const ok = await setOracleAuthority(payer.publicKey);
    if (!ok) {
      console.log("ERROR: Failed to set oracle authority. Are you the admin?");
      return;
    }
  }

  // Run all pen-tests
  const results: PenTestResult[] = [];

  results.push(await testPriceEdgeCases());
  results.push(await testTimestampAttack());
  results.push(await testFundingManipulation());
  results.push(await testFlashCrash());
  results.push(await testInsuranceDrain());
  results.push(await testADLCascade());

  // Summary
  console.log("\n" + "=".repeat(70));
  console.log("PEN-TEST RESULTS SUMMARY");
  console.log("=".repeat(70) + "\n");

  let vulnerabilities = 0;
  for (const r of results) {
    const status = r.passed ? "PASS" : "FAIL";
    console.log(`[${status}] ${r.name}`);
    console.log(`       ${r.details}`);
    if (r.vulnerability) {
      console.log(`       VULNERABILITY: ${r.vulnerability}`);
      vulnerabilities++;
    }
    console.log();
  }

  console.log("=".repeat(70));
  console.log(`Total: ${results.filter(r => r.passed).length}/${results.length} tests passed`);
  console.log(`Vulnerabilities found: ${vulnerabilities}`);
  console.log("=".repeat(70));
}

main().catch(console.error);
